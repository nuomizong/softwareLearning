% !Mode:: "TeX:UTF-8"

\chapter{\LaTeX{} operations}
\section{Show line numbers in editor}
Under \textbf{Options}, under \textbf{Configure TexStudio}, tick the \textbf{Show Advanced Options} checkbox, several menu items are made available, including \textbf{Adv.Editor}.

Under \textbf{Adv.Editor}, under \textbf{Appearance} section, there is a drop-down box \textbf{Show Line Numbers}:

%\begin{figure}[h]
%	\centering
%	\includegraphics[width=0.5\linewidth]{"Show Line Numbers"}
%	\caption{Show Line Numbers}	\label{fig: Show Line Numbers}
%	\vspace{\baselineskip}
%\end{figure}

\section{\textbackslash verb, \textbackslash texttt and \textbackslash verbatim}
\textbf{Q:} Sometimes people here use \lstinline[language={[LaTeX]TeX}]|\verb|A SHORT COMMAND|| and sometimes \lstinline[language={[LaTeX]TeX}]|\textt{A SHORT COMMAND}|. I'm unsure when to use which.

\textbf{A:} The short answer is you use \lstinline[language={[LaTeX]TeX}]|verb| where you need to write a small piece of \textbf{inline verbatim material} that contains characters \TeX{} treats (or rather, is currently treating) as special. \lstinline[language={[LaTeX]TeX}]|texttt| is for when you just want \textbf{typewriter} font.

\lstinline[language={[LaTeX]TeX}]|verb| has some downsides, such as not working in moving arguments. In those cases, you're probably better off using \textbf{\texttt} (or related semantic markup) and perform the appropriate escaping.

Sometimes using \lstinline[language={[LaTeX]TeX}]|\verb}\textbar...\textbar| is better. For example if you copy paste a piece of code like \textbf{\_\_start:} in a \lstinline[language={[LaTeX]TeX}]|texttt{}| environment you might get an error as symbol "\_" is not inside a math environment. And then you have to rewrite the code like this:\lstinline[language={[LaTeX]TeX}]|texttt{{__start}}|. But why would you do this when you can just use:"\textbackslash verb\textbar\_\_start\textbar".

\section{Horizontal lines}
To get horizontal lines of any fixed length you can use the \textbf{\textbackslash rule} command. To get a horizontal line spanning the whole page width you can use a \textbf{\textbackslash makebox} command and then a \textbf{\textbackslash rule} with a width equal to \textbf{\textbackslash paperwidth}:

Bellow is a line spanning the entire width of the page

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}} 

Bellow is a 2cm long line

\noindent\rule{2cm}{0.4pt}

Bellow is a 8cm long line

\noindent\rule{8cm}{0.4pt}

\begin{lstlisting}[language={[LaTeX]TeX}]
Bellow is a line spanning the entire width of the page

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
% need makebox to let line start at margin.

Bellow is a 2cm long line

\noindent\rule{2cm}{0.4pt}

Bellow is a 8cm long line
\end{lstlisting}
\noindent\hrule\vspace{1em}

Rules in \LaTeX~are \textbf{0.4pt} thick, by default.

\section{indent and no indent}
\begin{itemize}
	\item set indeng manually:
	\begin{itemize}
		\item \textbackslash indent
		\item \textbackslash noindent
	\end{itemize}
	\item set page indent style:
	\begin{itemize}
		\item \textbackslash setlength{\textbackslash parindent\{0pt\}}
		\item \textbackslash setlength{\textbackslash parindent\{2cm\}}
	\end{itemize}
\end{itemize}

\section{indent lines with arbitrary values}
\textit{Indentation} usually means that only the first line of a paragraph is indented (by the \textcolor{blue}{\textbackslash parindent} amount). You increased \textcolor{blue}{\textbackslash leftskip}, which means that the whole paragraph gets an increased left margin.

The usage is (for whole paragraph):\\
\colorbox{yellow}{\{\textbackslash addtolength\{\textbackslash leftskip\}\{2em\} This has an increased left margin.\textbackslash par\}}

An alternative to \textcolor{blue}{\textbackslash leftskip} is to use \textcolor{blue}{\textbackslash hangindent=2em}

If you only want to indent the first line of a paragraph ( or if you only have single lines anyway), then you can use

\colorbox{yellow}{\{\textbackslash addtolength\{\textbackslash parindent\}\{2em\} This has an additional indentation of 2em.\}}

\section{comments}
use \verb|%| to comment out comments.

\section{include space in filename}
If one file has a file name: "AA BB" then write \verb|\include{"AA\space BB"}|.

\section{include dot in filename}
If one png has a file name: "AA.BB.png" then write \verb|\includegraphics[width = 0.5\linewidth]{{AA.BB}.png}|.

\section{\textbackslash bfseries and \textbackslash textbf}
There is not so much practical difference between \colorbox{yellow}{\textbackslash textbf\{$ < $content$ > $\}} and \colorbox{yellow}{\{\textbackslash bfseries$ < $content$ > $\}}. 

\colorbox{yellow}{\textbackslash textbf} uses \colorbox{yellow}{\textbackslash bfseries} internally, so the latter is a more fundamental macro.

The \colorbox{yellow}{\textbackslash textbf} switches to text mode inside math mode, while \colorbox{yellow}{\textbackslash bfseries} apparently doesn't/ It also adds checks for italic correction before and after content.

So The \colorbox{yellow}{\textbackslash textbf} is used for smaller texts, mainly because of the italic correction, and in math mode. \colorbox{yellow}{\textbackslash bfseries} is \textbf{IMHO} more intended for environments and larger texts. One notable exception is if you have bold and italic (etc.) combinations, then you could write \colorbox{yellow}{\textbackslash textit\{\textbackslash bfseries $ < $content$ > $\}}, to avoid two sets of braces, but this is more a fashion choice.

\section{Hide text}
For simple text without any special \LaTeX{} macros (especially not \colorbox{yellow}{\textbackslash if...} macros) then \colorbox{yellow}{\textbackslash iffalse ... \textbackslash fi} for this:

\noindent
\framebox[\textwidth]{\parbox{\textwidth}{
		\textbackslash iffalse\\
		This text is ignored, but should not include 'if...' and 'fi' macros\\
		\textbackslash fi}}
		
\section{Getting \LaTeX{} to process multiple files}
As your work grows, your \LaTeX{} file can become unwieldy and confusing, especially if you are writing a long article with substantial, discrete sections, or a full-length book. In such cases it is good practice to split your work into several files. For example, if you are writing a book, it makes a lot of sense to write each chapter in a separate \textbf{.tex} file. \LaTeX{} makes this very easy thanks to two commands:

\begin{lstlisting}[language={[LaTeX]TeX}]
\input{filename}
\end{lstlisting}

and 

\begin{lstlisting}[language={[LaTeX]TeX}]
\include{filename}
\end{lstlisting}

\subsection{Comparing the methods: input vs include}
The differences between these two ways to include files is explained below. What they have in common is that they process the contests of \textbf{filename.tex} before continuing with the rest of the base file (the file that contains these statements). When the compiler processes your base file and reaches one of the commands \lstinline[language={[LaTeX]TeX}]|\input| or \lstinline[language={[LaTeX]TeX}]|\include|, it reads \textbf{filename.tex} and processes its content in accordance with the formatting commands specified in the base file. This way you can put all the formatting options in your base file and write the contents using \lstinline[language={[LaTeX]TeX}]|\input| or \lstinline[language={[LaTeX]TeX}]|\include| in the files which contain the actual content of your work. This means that the important part of your working process, i.e. writing, is kept largely separate from formatting choices. This is one of the main reasons why \LaTeX{} is so good for serious writing! You will thus be dealing solely with text and very basic commands such as \lstinline[language={[LaTeX]TeX}]|\section| or \lstinline[language={[LaTeX]TeX}]|\emph| etc. Your document will be uncluttered and much easier to work with.

The second method of including a file, \lstinline[language={[LaTeX]TeX}]|\include{filename}|, differs from the first in some important ways. You cannot nest \lstinline[language={[LaTeX]TeX}]|\include| statements within a file added via \lstinline[language={[LaTeX]TeX}]|\include|, whereas \lstinline[language={[LaTeX]TeX}]|\input|, on the other hand, allows you to call files which themselves call other files, ad infinitum. You can, however, \lstinline[language={[LaTeX]TeX}]|\include| a file which contains one or more \lstinline[language={[LaTeX]TeX}]|\input| commands. Please resist the temptation to nest files in this way simply because the system can do it: you will end up with just another kind of complexity!

Another importance difference is that using \lstinline[language={[LaTeX]TeX}]|\include| will force a page break (which makes it ideal for a book's chapters), whereas the \lstinline[language={[LaTeX]TeX}]|\input| command does not (which in turn makes it ideal for use within, say, a long article with discrete sections, which of course not normally set on a new page).

In either case the \textbf{.tex} filename extension is optional.

Working on discrete parts of your documents has consequences for how the base file is compiled; these will be dealt with below.

\subsection{Using different paths}
When the \LaTeX{}compiler finds a reference to an external file in the base file, it will look for it in the same directory. However, you can in principle refer to any file on your system, using both absolute and relative paths.

An \textit{absolute} path is a full path- and filename with every element specified. So, \lstinline[language={[LaTeX]TeX}]|filename.tex| might have the full path,

\begin{lstlisting}[language={[LaTeX]TeX}]
\input{/home/user/texfiles/filename.tex}
\end{lstlisting}

If you had created the directory \textbf{myfiles} for writing project, in your \textbf{textfiles} directory, its full path would be,

\begin{lstlisting}[language={[LaTeX]TeX}]
\input{/home/user/texfiles/myfiles/filename.tex}
\end{lstlisting}

Obviously, using absolute paths is inefficient if you are referring to a file in the current directory. If, however, you need to include a file which is always kept at a specific place in your system, you may refer to it with an absolute path, for example 

\begin{lstlisting}[language={[LaTeX]TeX}]
\input{/home/user/documents/useful/foo.tex}
\end{lstlisting}

In practice, an absolute file path is generally used when one has to refer to a file which is quite some way away in the file system (or perhaps even on a different server!). One word of warning: do not leave empty spaces in the filenames, they can cause ambiguous behaviour. Either leave no spaces or use underscores \_ instead.

You may, however, need to make your source portable (to another computer or to a different location of your harddisk), in which case relative paths should be used if you wish to avoid unnecessary rewriting of path names. Or, a relative path may simply be a more efficient and elegant way of referring to a file. A relative path is one which is defined in relation to the current directory, in our case the one which contains the base file. LaTeX uses the standard UNIX notation: with a simple dot . you refer to the current directory, and by two dots .. you refer to the previous directory, that is the one above the current directory in the file system tree. The slash / is used to separate the different components of a pathname: directories and filenames. So by ./ you refer to the current directory, by ../ you refer to the previous directory, by ../../ you refer to a directory which is two steps upwards in the filesystem tree. Writing

\begin{lstlisting}[language={[LaTeX]TeX}]
\input{./filename.tex}
\end{lstlisting}

will have \textit{exactly} the same effect as writing

\begin{lstlisting}[language={[LaTeX]TeX}]
\input{filename.tex}
\end{lstlisting}

but if you found it more convenient to put all your files in a sub-directory fo your current directory, called myfiles, you would refer to that file by specifying

\begin{lstlisting}[language={[LaTeX]TeX}]
\input{./myfiles/filename.tex}
\end{lstlisting}

Indeed, in our example of the absolute path above, you could refer to that file relatively, too:

\begin{lstlisting}[language={[LaTeX]TeX}]
\input{../../documents/useful/foo.tex}
\end{lstlisting}

Note that \lstinline[language={[LaTeX]TeX}]|\include{filename}| essentially does a \lstinline[language={[LaTeX]TeX}]|\clearpage| before and after \lstinline[language={[LaTeX]TeX}]|\include{filename}|, together with some magic to switch to another .aux file